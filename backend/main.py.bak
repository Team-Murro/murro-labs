# backend/main.py
import asyncio
from fastapi import FastAPI, Depends
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from sqlalchemy import func, desc, case
from database import get_db, Base, engine
from models import LottoDraw, Prediction, WinningStore
from contextlib import asynccontextmanager
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from schemas import PredictionCreate, PredictionResponse
from typing import List
from pydantic import BaseModel
from crawler import crawl_latest_lotto
from train_model import train
from predict import get_ai_prediction
from fortune import get_fortune_reading 
from store_crawler import crawl_past_winning_stores
from geocoder import update_store_coordinates
from menu import get_menu_recommendation
from pydantic import BaseModel
from datetime import datetime

Base.metadata.create_all(bind=engine)

# --- ìŠ¤ì¼€ì¤„ëŸ¬ ì‘ì—… ---
async def weekly_update_job():
    print("â° [ì£¼ê°„ ì‘ì—…] 1. ë¡œë˜ ë‹¹ì²¨ ë²ˆí˜¸ ì—…ë°ì´íŠ¸...")
    draw_result = await crawl_latest_lotto()
    if draw_result:
        print(f"âœ¨ {draw_result['turn']}íšŒì°¨ í™•ë³´! í¬ë¡¤ë§ ë° ì¬í•™ìŠµ ì§„í–‰...")
        await crawl_past_winning_stores()
        await asyncio.to_thread(update_store_coordinates)
        await asyncio.to_thread(train)
        print("âœ… [ì£¼ê°„ ì‘ì—… ì™„ë£Œ]")
    else:
        print("ğŸ’¤ ìµœì‹  íšŒì°¨ ì—†ìŒ.")

scheduler = AsyncIOScheduler()

@asynccontextmanager
async def lifespan(app: FastAPI):
    scheduler.add_job(weekly_update_job, 'cron', day_of_week='sat', hour=22, minute=0)
    scheduler.start()
    yield
    scheduler.shutdown()

app = FastAPI(lifespan=lifespan)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- ê¸°ë³¸ API ---
@app.get("/")
def read_root(): return {"message": "Murro AI Server Running"}

@app.get("/api/lotto/latest")
def get_latest_lotto(db: Session = Depends(get_db)):
    latest = db.query(LottoDraw).order_by(LottoDraw.turn.desc()).first()
    return latest if latest else {"message": "ë°ì´í„° ì—†ìŒ"}

@app.get("/api/lotto/predict")
def predict_lotto():
    result = get_ai_prediction()
    return {"predicted_numbers": result} if not isinstance(result, dict) or "error" not in result else result

@app.get("/api/lotto/{turn}")
async def get_lotto_by_turn(turn: int, db: Session = Depends(get_db)):
    return db.query(LottoDraw).filter(LottoDraw.turn == turn).first()

@app.post("/api/lotto/crawl")
async def run_crawler_manually():
    await weekly_update_job()
    return {"message": "ìˆ˜ë™ ì—…ë°ì´íŠ¸ ì‹œì‘"}

# --- ì˜ˆì¸¡ ë° ëª…ì˜ˆì˜ ì „ë‹¹ API ---
@app.post("/api/predictions")
async def create_prediction(pred: PredictionCreate, db: Session = Depends(get_db)):
    saved = []
    for nums in pred.games:
        new_p = Prediction(turn=pred.turn, p_num1=nums[0], p_num2=nums[1], p_num3=nums[2], p_num4=nums[3], p_num5=nums[4], p_num6=nums[5], username=pred.username)
        db.add(new_p)
        saved.append(new_p)
    db.commit()
    return {"message": "ë“±ë¡ ì„±ê³µ", "count": len(saved)}

# backend/main.py ì˜ get_predictions í•¨ìˆ˜ êµì²´

@app.get("/api/predictions/{turn}", response_model=List[PredictionResponse])
async def get_predictions(turn: int, db: Session = Depends(get_db)):
    # 1. í•´ë‹¹ íšŒì°¨ ë‹¹ì²¨ ë²ˆí˜¸ ì¡°íšŒ
    lotto = db.query(LottoDraw).filter(LottoDraw.turn == turn).first()
    
    # 2. í•´ë‹¹ íšŒì°¨ì˜ ì˜ˆì¸¡ ê¸°ë¡ ì¡°íšŒ
    preds = db.query(Prediction).filter(Prediction.turn == turn).all()
    
    # 3. ë‹¹ì²¨ ë²ˆí˜¸ê°€ ë°œí‘œëœ ê²½ìš°ì—ë§Œ ì±„ì  ë¡œì§ ìˆ˜í–‰
    if lotto:
        win = {lotto.num1, lotto.num2, lotto.num3, lotto.num4, lotto.num5, lotto.num6}
        
        # ë³€ê²½ì‚¬í•­ì´ ìˆëŠ”ì§€ ì¶”ì í•˜ëŠ” í”Œë˜ê·¸
        is_updated = False
        
        for p in preds:
            # [ìµœì í™”] ì´ë¯¸ ë“±ìˆ˜ê°€ ë§¤ê²¨ì§„(1ë“±~5ë“±, ë‚™ì²¨) ê±´ì€ ê³„ì‚° ê±´ë„ˆëœ€! 
            # 'ëŒ€ê¸°ì¤‘'ì¸ ê²ƒë§Œ ê³„ì‚°
            if p.rank == "ëŒ€ê¸°ì¤‘":
                my = {p.p_num1, p.p_num2, p.p_num3, p.p_num4, p.p_num5, p.p_num6}
                match = len(win & my)
                
                if match == 6: p.rank = "1ë“±"
                elif match == 5 and lotto.bonus in my: p.rank = "2ë“±"
                elif match == 5: p.rank = "3ë“±"
                elif match == 4: p.rank = "4ë“±"
                elif match == 3: p.rank = "5ë“±"
                else: p.rank = "ë‚™ì²¨"
                
                is_updated = True
        
        # ë³€ê²½ëœ ê²Œ ìˆì„ ë•Œë§Œ DB ì €ì¥ (ì†ë„ í–¥ìƒ)
        if is_updated:
            db.commit()
            
    return preds

# --- ìš´ì„¸ API ---
class FortuneRequest(BaseModel):
    birthDate: str; birthTime: str; gender: str
@app.post("/api/fortune")
async def read_fortune(req: FortuneRequest):
    return await get_fortune_reading(req.birthDate, req.birthTime, req.gender)

# --- [ìˆ˜ì • ì™„ë£Œ] ëª…ë‹¹ ë­í‚¹ API ---
@app.get("/api/stores/top")
def get_top_stores(db: Session = Depends(get_db)):
    # 1. ì¢Œí‘œ(lat) í•„í„° ì œê±° -> ì¢Œí‘œ ë³€í™˜ ì•ˆ ëœ ë°ì´í„°ë„ ë­í‚¹ì—” ë‚˜ì™€ì•¼ í•¨
    # 2. ì •í™•í•œ ì§‘ê³„ (count logic)
    results = db.query(
        WinningStore.store_name,
        WinningStore.address,
        WinningStore.lat,
        WinningStore.lng,
        # rankê°€ 1ì´ë©´ 1ì„ ë”í•¨ (íšŸìˆ˜ ì§‘ê³„)
        func.sum(case((WinningStore.rank == 1, 1), else_=0)).label('first_count'),
        func.sum(case((WinningStore.rank == 2, 1), else_=0)).label('second_count')
    ).group_by(
        WinningStore.store_name, 
        WinningStore.address, 
        WinningStore.lat, 
        WinningStore.lng
    ).order_by(
        desc('first_count'), 
        desc('second_count')
    ).limit(100).all()

    return [{
        "store_name": r.store_name,
        "address": r.address,
        "lat": r.lat if r.lat else 0.0, # ì¢Œí‘œ ì—†ìœ¼ë©´ 0.0ìœ¼ë¡œ ì²˜ë¦¬ (ì§€ë„ ì´ë™ ì‹œ ì˜ˆì™¸ì²˜ë¦¬ í•„ìš”)
        "lng": r.lng if r.lng else 0.0,
        "1st": int(r.first_count or 0),
        "2nd": int(r.second_count or 0)
    } for r in results]

@app.get("/api/stores/all")
def get_all_map_stores(db: Session = Depends(get_db)):
    """
    ì§€ë„ í‘œì‹œìš© API (ìˆ˜ì •ë¨)
    - ê¸°ì¡´: ë‹¹ì²¨ ë‚´ì—­ì„ ê·¸ëŒ€ë¡œ ë¦¬í„´ (í•€ì´ ì—¬ëŸ¬ ê°œ ê²¹ì¹¨, í†µê³„ ì•ˆ ë¨)
    - ë³€ê²½: ê°€ê²Œë³„ë¡œ ê·¸ë£¹í™”í•˜ì—¬ 1ë“±/2ë“± íšŸìˆ˜ë¥¼ ì§‘ê³„í•´ì„œ ë¦¬í„´ (í•€ 1ê°œ, í†µê³„ í¬í•¨)
    """
    # ì¢Œí‘œê°€ ìˆëŠ” ë°ì´í„°ë§Œ ëŒ€ìƒìœ¼ë¡œ ê°€ê²Œë³„ ê·¸ë£¹í™” ìˆ˜í–‰
    results = db.query(
        WinningStore.store_name,
        WinningStore.lat,
        WinningStore.lng,
        # 1ë“± íšŸìˆ˜ ì§‘ê³„
        func.sum(case((WinningStore.rank == 1, 1), else_=0)).label('first_count'),
        # 2ë“± íšŸìˆ˜ ì§‘ê³„
        func.sum(case((WinningStore.rank == 2, 1), else_=0)).label('second_count')
    ).filter(
        WinningStore.lat != None
    ).group_by(
        WinningStore.store_name,
        WinningStore.lat,
        WinningStore.lng
    ).all()

    # JSON ë³€í™˜
    return [{
        "name": r.store_name,
        "lat": r.lat,
        "lng": r.lng,
        "first_count": int(r.first_count or 0),
        "second_count": int(r.second_count or 0)
    } for r in results]

# ë©”ë‰´ ì¶”ì²œ ìš”ì²­ ìŠ¤í‚¤ë§ˆ
class MenuRequest(BaseModel):
    lat: float
    lng: float

@app.post("/api/menu/recommend")
async def recommend_menu(req: MenuRequest):
    now_str = datetime.now().strftime("%Hì‹œ %Më¶„")
    result = await get_menu_recommendation(req.lat, req.lng, now_str)
    return result    

